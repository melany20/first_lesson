- [Что такое Git?](#что-такое-git)
  - [Преимущества Git](#преимущества-git)
- [Установка и настройка](#установка-и-настройка)
- [Основные команды и сценарии их использования](#основные-команды-и-сценарии-их-использования)
  - [Создание репозитория](#создание-репозитория)
  - [Просмотр состояний и откат](#просмотр-состояний-и-откат)
  - [Работа с ветками](#работа-с-ветками)
    - [Создание веток](#создание-веток)
    - [Навигация по веткам](#навигация-по-веткам)
    - [Слияние веток](#слияние-веток)
    - [Работа с удалённым репозиторием](#работа-с-удалённым-репозиторием)
- [Как разрешать конфликты](#как-разрешать-конфликты)
  - [Универсальный алгоритм](#универсальный-алгоритм)
  - [Алгоритм для разрешения конфликтов слияния](#алгоритм-для-разрешения-конфликтов-слияния)
  - [Алгоритм создания pull request (PR)](#алгоритм-создания-pull-request-pr)

# Что такое Git?

Git — это набор консольных утилит, которые отслеживают и фиксируют изменения в файлах. Git создал Линус Торвальдс, пока разрабатывал ядра Linux: инструмент так понравился разработчикам, что его стали использовать в других проектах. Git позволяет сравнивать, анализировать, редактировать, сливать изменения и возвращаться назад к последнему сохранению. Этот процесс называется контролем версий. 

## Преимущества Git

* Сохранение истории изменений: можно вернуться назад и отредактировать файлы. Случается, что после добавления новых функций код ломается, и нужно срочно откатиться к предыдущей, отлично работающей версии — здесь Git просто незаменим.

* Одновременная работа над проектом нескольких специалистов. Даже если вся команда решит залить изменения в своих файлах в один и тот же момент, проект не сломается. 

* Распределённое хранение файлов: Независимость от одного центрального сервера, на котором хранятся файлы. Git работает локально, данные сохраняются в репозитории на жестком диске. Копию репозитория можно хранить онлайн, чтобы над одним проектом могли работать сразу нескольких людей, —— в этом помогают [GitHub](github.com), [BitBucket](bitbucket.com) и другие сервисы.

# Установка и настройка

Алгоритм установки Git зависит от ОС и заключается в следующем:
* На Linux откройте терминал и установите приложение при помощи пакетного менеджера вашего дистрибутива. Для Ubuntu команда будет выглядеть так: 'sudo apt-get install git'
* На Windows рекомендуем установить [Git for Windows](https://git-scm.com/downloads/win), так как он содержит и клиент с графическим интерфейсом, и эмулятор bash.
* На macOS проще всего воспользоваться [Homebrew](https://docs.brew.sh/Installation). После установки запустите его в терминале командой 'brew install git'.

Чтобы изменения, которые вы внесли в Git, были подписаны вашим именем и имейлом, запустите в терминале команды:
'''
git config --global user.name "My Name"
git config --global user.email myEmail@example.com
'''

Конфигурация (или настройки) хранятся в файле .gitconfig локального каталога. Чтобы сделать эти настройки глобальными, то есть применимыми ко всем проектам,  добавить флаг –global. Если вы этого не сделаете, они будут распространяться только на текущий репозиторий.

Для просмотра всех настроек системы служит команда 'git config --list'.

# Основные команды и сценарии их использования

![Диаграмма команд](/images/cheat-sheet.png) 
Как видно на картинке, все команды в Git можно разделить на несколько групп:
- Создание репозитория (create)
- Просмотр изменений (browse)
- Откат (revert)
- Обновление  файлов (update)
- Работа с ветками (branch)
- Внесение изменений (commit)
- Публикация изменений (publish)

Рассмотрим те, без которых никак не обойтись при работе с Git.

## Создание репозитория

1. Создайте на компьютере папку **git_exercise**.
`mkdir Desktop/git_exercise/`
2. Перейдите в папку **git_exercise**.
`cd Desktop/git_exercise/`
3. Объявите эту папку репозиторием, или проинициализируйте её.
`git init`

В результате в терминале отобразится:
```
Initialized empty Git repository in /home/user/Desktop/<git_exercise>/.git/
```
Это значит, что репозиторий был создан, но пока пуст. 

4. Начните наполнять репозиторий: создайте текстовый файл **hello.txt** в папке **git_exercise**:
```
touch hello.txt
```
5. Привяжите локальный репозиторий к удалённому с URL https://github.com/melany20/first-lesson.git 
`git remote add origin https://github.com/melany20/first-lesson.git` (от англ. remote, «удалённый» + add, «добавить»).

6. Проверьте, что репозитории действительно связались
`git remote -v` 

7. В первый раз загрузите все коммиты из локального репозитория в удалённый с названием origin
`git push -u origin main`

> [!TIP]
> * Команды необязательно печатать и выполнять по очереди. Можно указать их списком — разделить двумя амперсандами (&&).
> * У консоли есть собственная память — буфер с несколькими последними командами. По ним можно перемещаться с помощью клавиш со стрелками вверх (↑) и вниз (↓).
> * Чтобы не вводить название файла или папки полностью, можно набрать первые символы имени и дважды нажать Tab. Если файл или папка есть в текущей директории, командная строка допишет путь сама. Например, вы находитесь в папке dev. Начните вводить cd first и дважды нажмите Tab. Если папка first-project есть внутри dev, командная строка автоматически подставит её имя. Останется только нажать Enter.

## Просмотр состояний и откат

Команда `status` отображает информацию о текущем состоянии репозитория. Введите в окне терминала `$ git status` и получите результат:

```
On branch master
Initial commit
Untracked files:
(use "git add ..." to include in what will be committed)
hello.txt
```

Это значит, что файл hello.txt неотслеживаемый: система еще не знает, нужно ли следить за изменениями в файле или их можно игнорировать. 

Чтобы начать отслеживать новый файл, нужно его проиндексировать командой `git add` и отправить в репозиторий командой `git commit`.

Жизненный цикл файла выглядит примерно так:
![Круговорот файлов в Git](/images/scheme.png)

Проиндексируйте файл командой `git add hello.txt` или `git add .`, чтобы добавить в индекс сразу все изменения.
Снова проверьте статус `git status`, получите:

```
On branch master
Initial commit
Changes to be committed:
(use "git rm --cached ..." to unstage)
new file: hello.txt
```

Пришло время отправить изменения в репозиторий: `git commit -m "Комментарий к коммиту"`
Флажок -m задаст commit message - комментарий, который поможет описать изменения.

Для просмотра всех коммитов вызовите команду `git log`, которая отобразит хэш, автора, список изменений и даты каждого коммита. 
Команда `git log --oneline` покажет краткую информацию о коммитах: сокращённый хеш и сообщение.

Отследить интересующие операции в списке изменений можно по хэшу — идентификатору — коммита при помощи команды `git show`:
```
$ git show hash_commit
```
Чтобы посмотреть изменения:
- в «рабочей зоне» (в modified-файлах), введите команду `git diff`, 
- в staged-файлах — `git diff --staged`

Чтобы вывести разницу между двумя коммитами — `git diff commit1..commit2` (например `git diff a9928ab 11bada1`)

Для отката коммитов служат команды:
- `git restore --staged hello.txt` — переводит файл hello.txt из состояния staged обратно в untracked или modified
- `git restore hello.txt` — возвращает файл hello.txt к последней версии, которая была сохранена через git commit или git add
- `git reset --hard b576d89` — удаляет все незакоммиченные изменения из staging и «рабочей зоны» вплоть до указанного коммита

## Работа с ветками
### Создание веток
Создать ветку: `git branch <имя ветки>`
Создать ветку и переключиться на неё: `git checkout -b <имя ветки>`.

### Навигация по веткам
Отобразить все ветки репозитория: `git branch`. Текущая ветка будет отмечена символом *.
Показать все известные ветки (локальные, и удалённые): `git branch -a`.
Переключиться на ветку `git checkout <имя ветки>`.

### Слияние веток
Объединить ветку main с текущей активной веткой `git merge main`. 

### Работа с удалённым репозиторием
Отправить дополнительные изменения в ветку, которая уже существует в удалённом репозитории `git push <имя ветки>` 
Подтянуть изменения текущей ветки из удалённого репозитория `git pull`.

# Как разрешать конфликты
## Универсальный алгоритм
1. Перейдите в ветку main.
1. Загрузите новые изменения из неё с помощью `git pull`. Заодно вы загрузите обновленную ветку.
1. Вернитесь в свою ветку.
1. Выполните `git merge main` и разрешите конфликт локально. В результате будет создан локальный коммит слияния.
1. Отправьте новые изменения без конфликтов обратно в удалённый репозиторий командой `git push`.

## Алгоритм для разрешения конфликтов слияния
1. Откройте проект в IDE (VS Code, IDEA или другие).
1. Откройте конфликтный файл.
2. Выберите, какие части файла нужно взять из одной ветки, а какие — из другой.
1. Когда конфликты разрешены, сделать коммит: `git commit --no-edit` или `git commit -m "merge branch <название ветки>"`.

## Алгоритм создания pull request (PR)
1. Склонируйте репозиторий.
   - Если вы не участник проекта, предварительно «форкните» исходный репозиторий.
   - На странице репозитория или «форка» выберите Code → SSH → скопировать ссылку.
   - Выполните команду `git clone <скопированная ссылка на репозиторий>`.
2. Создайте ветку для вашей задачи: `git checkout -b my-task-branch-name`.
3. Добавьте и «закоммитьте» изменения, которые вы хотите внести в проект.
4. «Запушьте» ветку: `git push --set-upstream origin HEAD` или `git push -u origin my-task-branch-name`.
   - GitHub выведет ссылку на создание PR. Перейдите по ней.
   - PR можно также создать через интерфейс GitHub.
5. Сообщите о пул-реквесте ревьюеру.
   - Иногда ревьюеры назначаются автоматически, тогда сообщать не нужно.
   - Обсуждать с ревьюером предлагаемые изменения и вносить правки, пока эти изменения не будут одобрены (пока не будет получен «апрув»).  

6. Если кто-то добавил конфликтующие изменения в main, пока ваш PR был на ревью, нужно разрешить конфликт:  
   - Обновите main: git checkout main && git pull.
   - Влейте main в свою ветку: git checkout my-task-branch-name && git merge main.
   - [Разрешите конфликты слияния](##Алгоритм_для_разрешения_конфликтов_слияния).
   - Сделайте git push своей ветки.

7. Нажмите кнопку **Merge** или подождите, пока её нажмёт кто-то ещё.

8. Ещё раз обновите main, чтобы «подтянуть» ваши изменения в основную ветку локального репозитория: git checkout main && git pull.

Готово!